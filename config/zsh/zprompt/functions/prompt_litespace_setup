# vim:set ft=zsh sw=2 sts=2 ts=2 et:
#
# For my own and others sanity
# git:
# %b => current branch
# %a => current action (rebase/merge)
# prompt:
# %F => color dict
# %f => reset color
# %~ => current path
# %* => time
# %n => username
# %m => shortname host
# %(?..) => prompt conditional - %(condition.true.false)
# terminal codes:
# \e7   => save cursor position
# \e[2A => move cursor 2 lines up
# \e[1G => go to position 1 in terminal
# \e8   => restore cursor position
# \e[K  => clears everything after the cursor on the current line
# \e[2K => clear everything on the current line

LITESPACE_PROMPT_VICMD_SYMBOL=''
LITESPACE_PROMPT_SYMBOL=''

ZSH_GIT_PROMPT_FORCE_BLANK=1
ZSH_GIT_PROMPT_SHOW_STASH=1
ZSH_THEME_GIT_PROMPT_PREFIX="%F{7}on "
ZSH_THEME_GIT_PROMPT_SUFFIX="%F{4}]%f"
ZSH_THEME_GIT_PROMPT_SEPARATOR=""
ZSH_THEME_GIT_PROMPT_DETACHED="%F{13}"
ZSH_THEME_GIT_PROMPT_BRANCH="%F{13} "
ZSH_THEME_GIT_PROMPT_BRANCH_SUFFIX=" %F{4}[%f"
ZSH_THEME_GIT_PROMPT_BEHIND="%F{13}↓"
ZSH_THEME_GIT_PROMPT_AHEAD="%F{13}↑"
ZSH_THEME_GIT_PROMPT_DELETED="%F{1}"
ZSH_THEME_GIT_PROMPT_STAGED="%F{2}"
ZSH_THEME_GIT_PROMPT_MODIFIED="%F{4}"
ZSH_THEME_GIT_PROMPT_UNTRACKED="%F{7}"
ZSH_THEME_GIT_PROMPT_STASHED="%F{6}"
#ZSH_THEME_GIT_PROMPT_UNMERGED="%{$fg[red]%}✖"
#ZSH_THEME_GIT_PROMPT_UNSTAGED="%{$fg[red]%}✚"
#ZSH_THEME_GIT_PROMPT_CLEAN="%{$fg_bold[green]%}✔"


# overwrite git-prompt function
function _zsh_git_prompt_git_status() {
    emulate -L zsh
    {
      [[ -n "$ZSH_GIT_PROMPT_SHOW_STASH" ]] && (
        c=$(git rev-list --walk-reflogs --count refs/stash 2> /dev/null)
        [[ -n "$c" ]] && echo "# stash.count $c"
      )
      c="$(command git describe --contains --all HEAD 2> /dev/null)"
      [[ -n "$c" ]] && echo "# position $c"
      c="${$(command git symbolic-ref HEAD 2> /dev/null)#refs/heads/}"
      [[ -n "$c" ]] && echo "# branch $c"
      command git status --branch --porcelain=v2 2>&1 || echo "fatal: git command failed"
    } | $ZSH_GIT_PROMPT_AWK_CMD \
        -v PREFIX="$ZSH_THEME_GIT_PROMPT_PREFIX" \
        -v SUFFIX="$ZSH_THEME_GIT_PROMPT_SUFFIX" \
        -v SEPARATOR="$ZSH_THEME_GIT_PROMPT_SEPARATOR" \
        -v DETACHED="$ZSH_THEME_GIT_PROMPT_DETACHED" \
        -v BRANCH="$ZSH_THEME_GIT_PROMPT_BRANCH" \
        -v BRANCH_SUFFIX="$ZSH_THEME_GIT_PROMPT_BRANCH_SUFFIX" \
        -v BEHIND="$ZSH_THEME_GIT_PROMPT_BEHIND" \
        -v AHEAD="$ZSH_THEME_GIT_PROMPT_AHEAD" \
        -v UNMERGED="$ZSH_THEME_GIT_PROMPT_UNMERGED" \
        -v DELETED="$ZSH_THEME_GIT_PROMPT_DELETED" \
        -v MODIFIED="$ZSH_THEME_GIT_PROMPT_MODIFIED" \
        -v STAGED="$ZSH_THEME_GIT_PROMPT_STAGED" \
        -v UNSTAGED="$ZSH_THEME_GIT_PROMPT_UNSTAGED" \
        -v UNTRACKED="$ZSH_THEME_GIT_PROMPT_UNTRACKED" \
        -v STASHED="$ZSH_THEME_GIT_PROMPT_STASHED" \
        -v CLEAN="$ZSH_THEME_GIT_PROMPT_CLEAN" \
        -v RC="%{$reset_color%}" \
        '
          BEGIN {
            ORS = "";

            fatal = 0;
            oid = "";
            branch = "";
            poistion = "";
            head = "";
            ahead = 0;
            behind = 0;
            modified = 0;
            deleted = 0;
            untracked = 0;
            unmerged = 0;
            staged = 0;
            unstaged = 0;
            stashed = 0;
            result = "";
            firstflg = 0;
          }

          $1 == "fatal:" {
            fatal = 1;
          }

          $2 == "branch.oid" {
            oid = $3;
          }

          $2 == "branch.head" {
            head = $3;
          }

          $2 == "branch.ab" {
            ahead = $3;
            behind = $4;
          }

          $1 == "?" {
            ++untracked;
          }

          $1 == "u" {
            ++unmerged;
          }

          $1 == "1" || $1 == "2" {
            split($2, arr, "");
            if (arr[1] != ".") {
              ++staged;
            }
            if (arr[2] != ".") {
              ++unstaged;
            }
            if (arr[2] == "M") {
              ++modified;
            }
            if (arr[2] == "D") {
              ++deleted;
            }
          }

          $2 == "stash.count" {
            stashed = $3;
          }

          $2 == "branch" {
            branch = $3;
          }

          $2 == "position" {
            position = $3;
          }

          END {
            if (fatal == 1) {
              exit(1);
            }

            result = result PREFIX RC BRANCH;

            if (branch != "") {
              result = result branch;
            } else if ( position != "" ) {
              result = result position;
            } else {
              result = result substr(oid, 0, 7);
            }
            result = result RC;

            if (unmerged == 0 && staged == 0 && unstaged == 0 && untracked == 0 && behind == 0 && ahead == 0) {
              print result;
              exit;
            }

            result = result BRANCH_SUFFIX;

            if (behind < 0) {
                result = result BEHIND;
                result = result sprintf("%d", behind * -1);
                result = result RC;
            }

            if (ahead > 0) {
              result = result AHEAD;
              result = result sprintf("%d", ahead);
              result = result RC;
            }

            result = result SEPARATOR;

            if (stashed > 0) {
              result = result STASHED;
              result = result stashed;
              result = result RC " ";
            }

            if (staged > 0) {
              result = result STAGED;
              result = result staged;
              result = result RC " ";
            }

            if (deleted > 0) {
              result = result DELETED;
              result = result deleted;
              result = result RC " ";
            }

            if (modified > 0) {
              result = result MODIFIED;
              result = result modified;
              result = result  RC " ";
            }

            if (untracked > 0) {
              result = result UNTRACKED;
              result = result untracked;
              result = result RC " ";
            }

            result = result SUFFIX;
            result = result RC;
            gsub(" " SUFFIX, SUFFIX, result)
            print result;
          }
        '
}

# borrowed from pure
# https://github.com/sindresorhus/pure/blob/master/pure.zsh
function __litespace_set_title() {
  setopt localoptions noshwordsplit

  # Emacs terminal does not support settings the title.
  (( ${+EMACS} )) && return

  case $TTY in
    # Don't set title over serial console.
    /dev/ttyS[0-9]*) return;;
  esac

  # Show hostname if connected via SSH.
  local hostname=
  [[ -n $SSH_CONNECTION ]] && hostname="${(%):-SSH:(%m) }"


  # Set title atomically in one print statement so that it works when XTRACE is enabled.
  print -Pn  $'\e]0;'${hostname:-$__litespace_pwd}$'\a'
}

function __litespace_import_tmux_env() {
  # preexec function
  [[ -n "$TMUX" ]]  || return 0
  sshauth=$(tmux show-environment | grep "^SSH_AUTH_SOCK")
  if [ $sshauth ]; then
    export $sshauth
  fi
  display=$(tmux show-environment | grep "^DISPLAY")
  if [ $display ]; then
    export $display
  fi

}

# Set $psvar[12] to the current Python virtualenv
function __litespace_set_venv() {
  psvar[12]=
  if [[ -n $VIRTUAL_ENV ]] && [[ -n $VIRTUAL_ENV_DISABLE_PROMPT ]]; then
    psvar[12]="${VIRTUAL_ENV:t}"
  fi
}

# Draw a newline between every prompt
function prompt_litespace_precmd_newline() {
  print -Pn '$prompt_newline'
}

function __litespace_user() {
  if [[ $LOGNAME != $USER ]] \
    || [[ $UID == 0 ]] \
    || [[ $ZSH_THEME_LITESPACE_SHOW_USER ]]; then
      print -P '%F{9}%n%f '
  fi
}

function __litespace_host() {
  if [[ -n $SSH_CONNECTION ]] \
    || [[ $ZSH_THEME_LITESPACE_SHOW_HOST ]]; then
      print -P '%F{7}at %f%F{3}%m%f '
  fi
}

function prompt_litespace_preexec() {
  __litespace_import_tmux_env
  __litespace_set_title
}


function prompt_litespace_precmd() {
  __litespace_pwd=$(prompt-pwd)
  __litespace_set_venv
  __litespace_set_title
}

function __litespace_update_vim_prompt_widget() {
  setopt localoptions noshwordsplit
  prompt_litespace_state=${${KEYMAP/vicmd/${LITESPACE_PROMPT_VICMD_SYMBOL}}/(main|viins)/${LITESPACE_PROMPT_SYMBOL}}
  zle reset-prompt
}

function __litespace_reset_vim_prompt_widget() {
  setopt localoptions noshwordsplit
  prompt_litespace_state=${LITESPACE_PROMPT_SYMBOL}
}


function prompt_litespace_setup() {
  setopt LOCAL_OPTIONS
  unsetopt XTRACE KSH_ARRAYS
  prompt_opts=(cr percent subst)

  # Borrowed from `promptinit`. Sets the prompt options in case litespace  was not
  # initialized via `promptinit`.
  setopt noprompt{bang,cr,percent,subst} "prompt${^prompt_opts[@]}"

  if [[ -z $prompt_newline ]]; then
    # This variable needs to be set, usually set by promptinit.
    typeset -g prompt_newline=$'\n%{\r%}'
  fi

  typeset -g prompt_litespace_state=${LITESPACE_PROMPT_SYMBOL}

  # Load required functions.
  autoload -Uz add-zsh-hook
  autoload -Uz +X add-zle-hook-widget 2>/dev/null
  autoload -Uz prompt-pwd 2> /dev/null

  # Prevent Python virtualenv from modifying the prompt
  export VIRTUAL_ENV_DISABLE_PROMPT=1

  add-zsh-hook precmd  prompt_litespace_precmd
  add-zsh-hook precmd  prompt_litespace_precmd_newline
  add-zsh-hook preexec prompt_litespace_preexec

  # To avoid glitching with fzf's alt+c binding we override the fzf-redraw-prompt widget.
  # The widget by default reruns all precmd hooks, which prints the newline again.
  # We therefore run all precmd hooks except _prompt_newline.
  function fzf-redraw-prompt() {
    local precmd
    for precmd in ${precmd_functions:#prompt_litespace_precmd_newline}; do
      $precmd
    done
    zle reset-prompt
  }

  zle -N __litespace_update_vim_prompt_widget
  zle -N __litespace_reset_vim_prompt_widget
  if (( $+functions[add-zle-hook-widget] )); then
    add-zle-hook-widget zle-line-finish __litespace_reset_vim_prompt_widget
    add-zle-hook-widget zle-keymap-select __litespace_update_vim_prompt_widget
  fi

  # In the second line of the prompt $psvar[12] is read
  PROMPT=$'$(__litespace_user)$(__litespace_host)'
  PROMPT=$'%F{7}in %f%F{2}$__litespace_pwd%f %F{242}$(gitprompt)%f'
  PROMPT+=$'$prompt_newline'
  PROMPT+=$'%(12V.%F{242}%12v%f .)%(?.%F{cyan}.%F{red})${prompt_litespace_state}%f '
  RPROMPT=''
}

prompt_litespace_setup "$@"
